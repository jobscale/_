#!/usr/bin/env bash

IMAGE="kindest/node:v1.27.1"

production() {
  export KINDNAME=production
  export KINDCONFIG=kindest/production.yaml
}
staging() {
  export KINDNAME=staging
  export KINDCONFIG=kindest/staging.yaml
}
development() {
  export KINDNAME=development
  export KINDCONFIG=kindest/development.yaml
}

development

initializeDatabase() {
  SQL="CREATE DATABASE IF NOT EXISTS wordpress;
CREATE USER IF NOT EXISTS 'wp-user'@'%' IDENTIFIED BY 'wp-admin';
GRANT ALL PRIVILEGES ON wordpress.* TO 'wp-user'@'%' WITH GRANT OPTION;
FLUSH PRIVILEGES;"

  kubectl exec -n mariadb -i svc/mariadb -- bash -c "echo \"$SQL\" | mysql -p$1"

  SQL="CREATE DATABASE IF NOT EXISTS redmine;
CREATE USER IF NOT EXISTS 'redmine-user'@'%' IDENTIFIED BY 'redmine-admin';
GRANT ALL PRIVILEGES ON redmine.* TO 'redmine-user'@'%' WITH GRANT OPTION;
FLUSH PRIVILEGES;"

  kubectl exec -n mysql -i svc/mysql -- bash -c "echo \"$SQL\" | mysql -pmy-secret-pw"
}

k8sVolume() {
  MNT_DIR=/home/k8s/mnt/var/lib
  sudo mkdir -p $MNT_DIR/_empty
  sudo chown root:adm $MNT_DIR/*
  sudo chmod g+rX $MNT_DIR/*
  sudo tree -h -L 2 $MNT_DIR
}

allInOne() {
  k8sVolume
  echo -n "setup '$KINDNAME' deployment "
  read -p "ok? (y/N): " yn; case "$yn" in [yY]*) echo "continue";; *) echo "abort" && return;; esac

  cleanKind
  LOGFILE=/home/k8s/logs/kind-$KINDNAME-$(date +'%Y-%m-%d-%H:%M:%S').log
  time inAllInOne 2>&1 | tee $LOGFILE
}

cleanKind() {
  sudo rm -fr /home/k8s/system
  sudo rm -fr /home/k8s/mnt
  sudo mkdir -p /home/k8s/logs
  sudo chown -R $(id -un):$(id -gn) /home/k8s/logs
}

inAllInOne() {
  createKind

  # pullImages

  kubectl apply -f limitrange-limits.yaml -n default
  k8sApps
  firstApps
  deployDatabase

  ingressForward
  [[ $KINDNAME == production ]] && initializeDatabase false

  createStandard

  [[ $KINDNAME == production ]] && cronJob
  [[ $KINDNAME == production ]] && deployWordpress

  ingressRestart

  echo -n "        ending" && loop 20
  kubectl get pods -A -o wide
  kubectl top pods -n standard --containers | sort -h -k 4
  docker exec -i $KINDNAME-control-plane crictl images > images-$KINDNAME-list
  echo -e '\n\nk8s creation finished.\n\n'

  token && postSlack "$(token)"
  echo Completed.
}

createKind() {
  DATE=$(date +'%Y-%m-%d_%H:%M:%S')
  [[ -s $HOME/.kube/config ]] && mv $HOME/.kube/config $HOME/.kube/save-config_$DATE
  docker pull "$IMAGE"
  kind create cluster --name $KINDNAME --config $KINDCONFIG --image "$IMAGE"
  cp $HOME/.kube/config $HOME/.kube/kind-config-$KINDNAME-$DATE
  sed -i -e 's/0\.0\.0\.0/kubernetes/' $HOME/.kube/config

  echo -n "        wait for nodes system pods initializing"
  for i in {1..99}
  do
    loop 5
    [[ $(kubectl get all -A | grep -e 0/1 | wc -l) == 0 ]] && break
    kubectl get all -A | grep -e 0/1 || echo
  done
}

metricsServer() {
  METRICS_SERVER_VERSION=$(git ls-remote --refs --tags https://github.com/kubernetes-sigs/metrics-server.git | sort -t '/' -k 3 -V | tail -1 | awk -F/ '{print $3}')
  echo "kubernetes-sigs metrics-server $METRICS_SERVER_VERSION"
  METRICS_SERVER_VERSION=v0.4.1
  # curl -sLo metrics-server/components.yaml https://github.com/kubernetes-sigs/metrics-server/releases/download/${METRICS_SERVER_VERSION}/components.yaml
  kubectl apply -f metrics-server
}

metalLB() {
  METAL_VERSION=$(git ls-remote --tags --refs https://github.com/danderson/metallb.git | sort -t '/' -k 3 -V | tail -1 | awk -F/ '{print $3}')
  METAL_SECRET=$(openssl rand -base64 128 | xargs | sed -e 's/ //g')
  echo -e "\n MetalLB ${METAL_VERSION} \n"
  kubectl create namespace metallb-system
  kubectl create secret generic -n metallb-system memberlist --from-literal=secretkey=$METAL_SECRET
  kubectl apply -f metalLB/metallb.yaml
  kubectl apply -f metalLB/km-config.yaml
  waitFor metallb-system
}

adminDashboard() {
  DASHBOARD_VERSION=$(git ls-remote --refs --tags https://github.com/kubernetes/dashboard.git | sort -t '/' -k 3 -V | tail -1 | awk -F/ '{print $3}')
  echo -e "\n Kubernetes Dashboard ${DASHBOARD_VERSION} \n"
  curl -so dashboard/kubernetes-dashboard.yaml https://raw.githubusercontent.com/kubernetes/dashboard/${DASHBOARD_VERSION}/aio/deploy/recommended.yaml
  kubectl apply -f dashboard/kubernetes-dashboard.yaml
  kubectl apply -f dashboard/admin-user-service-account.yaml
  . dashboard/admin-user-secret.yaml
  waitFor kubernetes-dashboard
}

token() {
  [[ "$(kubectl get namespaces | grep kubernetes-dashboard)" == "" ]] && echo 'no token' && return
  kubectl describe secrets -n kubernetes-dashboard admin-user | grep ^token | awk '{print $2}'
}

internalService() {
  kubectl create namespace net-apps
  kubectl apply -f limitrange-limits.yaml -n net-apps
  kubectl apply -f net-apps
  waitFor bind9
  waitFor squid
}

deployDatabase() {
  kubectl apply -f mariadb && waitFor mariadb
  kubectl apply -f postgres && waitFor postgres
  kubectl apply -f mysql && waitFor mysql
  kubectl get all -A | grep -e mariadb -e mysql
}

k8sApps() {
  metricsServer
  metalLB
  adminDashboard
}

firstApps() {
  internalService
  jsxSite
}

jsxSite() {
  [[ $KINDNAME == production || $KINDNAME == staging ]] && partner/create-secret.sh && kubectl apply -f partner && waitFor partner
  kubectl create namespace jsxjp
  kubectl apply -n jsxjp -f limitrange-limits.yaml
  kubectl apply -n jsxjp -f jsxjp && waitFor jsxjp
}

ingressForward() {
  kubectl apply -n default -f web && waitFor web
  kubectl exec -n default -it svc/web -- bash -c "curl -I -s jsxjp.jsxjp.svc.cluster.local:3000"
}

ingressRestart() {
  kubectl rollout restart deployment web
}

deployWordpress() {
  kubectl create namespace wordpress
  kubectl apply -n wordpress -f limitrange-limits.yaml
  kubectl apply -n wordpress -f wordpress && waitFor wordpress
}

createStandard() {
  kubectl create namespace standard
  kubectl apply -n standard -f limitrange-limits.yaml
  kubectl config set-context $(kubectl config current-context) --namespace standard

  exposeCluster standard redis redis 6379 6379
  exposeCluster standard mongo mongo 27017 27017
  exposeCluster standard ddb amazon/dynamodb-local 80 8000 0

  [[ $KINDNAME == production ]] && deployApps
  [[ $KINDNAME == production || $KINDNAME == staging ]] && initWetty

  kubectl describe nodes
  kubectl config set-context $(kubectl config current-context) --namespace default
}

initWetty() {
  kubectl apply -f wetty && waitFor wetty
  TTY_PASSWD="$(makePasswd)"
  genPasswd "$TTY_PASSWD"
  echo "Initialized password: '$TTY_PASSWD'"
  postSlack "Initialized password: '$TTY_PASSWD'"
}

makePasswd() {
  head -c 8 /dev/random | mkpasswd -s -5 | sed -e 's/\$//g' | sed -e 's/^1//'
}

genPasswd() {
  GEN_PASSWD="$1"
  [[ "$GEN_PASSWD" == "" ]] && echo -e "failed password.\nusage:\n\n  GEN_PASSWD='$(makePasswd)' genPasswd\n" && return
  kubectl exec -i $(kubectl get pods | grep ^wetty- | awk '{print $1}') -- bash -c "echo bullseye:$GEN_PASSWD | chpasswd"
}

cronJob() {
  [[ "$KINDNAME" != production ]] && return
  [[ "$(hostname)" != focal ]] && return
  # kubectl create namespace health-check
  # kubectl create cronjob -n health-check value-domain --image ghcr.io/jobscale/value-domain --schedule='0/7 * * * *'
  ## Create One time job
  # kubectl create job -n health-check value-domain-$(date +%s%3N) --from=cronjob.batch/value-domain

  kubectl create namespace cron-job
  kubectl create cronjob -n cron-job kabuka --image ghcr.io/jobscale/kabuka --schedule='57 7 * * 1-5'
  ## Create One time job
  # kubectl create job -n cron-job kabuka-$(date +%s%3N) --from=cronjob.batch/kabuka

  kubectl create cronjob -n cron-job news-top --image ghcr.io/jobscale/news-top --schedule='53 * * * *'
  ## Create One time job
  # docker exec -it ${ENV:-production}-control-plane crictl pull ghcr.io/jobscale/news-top
  # kubectl create job -n cron-job news-top-$(date +%s%3N) --from=cronjob.batch/news-top

  kubectl create cronjob -n cron-job info-certificate --image ghcr.io/jobscale/info-certificate --schedule='48 23 * * *'
  ## Create One time job
  # docker exec -it ${ENV:-production}-control-plane crictl pull ghcr.io/jobscale/info-certificate
  # kubectl create job -n cron-job info-certificate-$(date +%s%3N) --from=cronjob.batch/info-certificate

  kubectl create cronjob -n cron-job speedtest --image ghcr.io/jobscale/speedtest --schedule '56 23 * * *'
  ## Create One time job
  # docker exec -it ${ENV:-production}-control-plane crictl pull ghcr.io/jobscale/speedtest
  # kubectl create job -n cron-job speedtest-$(date +%s%3N) --from=cronjob.batch/speedtest
}

deployNode() {
  kubectl apply -f mqtt && waitFor mqtt
  kubectl apply -f node-aws && waitFor node-aws
  kubectl apply -f code-server && waitFor code-server
  kubectl apply -f tanpo && waitFor tanpo
  kubectl apply -f exp && waitFor exp
  exposeLoadBalancer standard zipcode-jp ghcr.io/jobscale/zipcode-jp 80 3000 3
  exposeLoadBalancer standard sshwifty ghcr.io/jobscale/sshwifty 80 8182 3
  exposeLoadBalancer standard mongo-blog ghcr.io/jobscale/mongo-blog 80 3000 3
  exposeLoadBalancer standard todo ghcr.io/jobscale/todo-app 80 3000 0
  exposeLoadBalancer standard room-chat jobscale/room-chat 80 3000 0
  exposeLoadBalancer standard simple-chat jobscale/simple-chat 80 3000 0
}

deployNginx() {
  exposeLoadBalancer standard anywaychat ghcr.io/jobscale/anywaychat-web 80 80 3
  exposeLoadBalancer standard ramen-timer ghcr.io/jobscale/ramen-timer 80 80 3
  exposeLoadBalancer standard tetris ghcr.io/jobscale/tetris 80 80 3
}

deployPhp() {
  exposeLoadBalancer standard profile ghcr.io/jobscale/profile 80 80 3
  exposeLoadBalancer standard laravel ghcr.io/jobscale/laravel 80 80 3
  exposeLoadBalancer standard lumen ghcr.io/jobscale/lumen 80 80 3
  exposeLoadBalancer standard dokuwiki jobscale/dokuwiki 80 80 3
  exposeLoadBalancer standard ec-cube ghcr.io/jobscale/ec-cube 80 80 3
  kubectl apply -f redmine && waitFor redmine
  {
    kubectl create namespace health-check
    kubectl apply -f cronjob/ec-cube-check.yaml
    kubectl apply -f cronjob/ec-cube-healthy.yaml
  }
}

deployPython() {
  exposeLoadBalancer standard tutorial docker/getting-started 80 80 3
  exposeLoadBalancer standard python-fastapi ghcr.io/jobscale/python-fastapi 80 80 3
  # kubectl apply -f django && waitFor django
}

deployEcho() {
  exposeLoadBalancer standard echo-server inanimate/echo-server 80 8080 3
}

deployApps() {
  echo "####################################################"
  echo "##### start mix logs"
  echo "####################################################"
  deployNode &
  deployNginx &
  deployPhp &
  deployPython &
  deployEcho &
  wait
  echo "####################################################"
  echo "##### finish mix logs"
  echo "####################################################"
}

exposeLoadBalancer() {
  local NAME_SPACE=$1
  local NAME=$2
  local IMAGE=$3
  local PORT=$4
  local TARGET=$5
  local MIN_REPLICA=$6
  local MIN_REPLICA=1 # kubernetes.io/limit-ranger: LimitRanger plugin set: cpu, memory request for container
  kubectl create deployment -n $NAME_SPACE $NAME --image $IMAGE
  kubectl expose deployment -n $NAME_SPACE $NAME --name $NAME --type LoadBalancer --port $PORT --target-port $TARGET
  [[ "$MIN_REPLICA" != "0" ]] && kubectl autoscale deployment $NAME \
  --cpu-percent 50 --min $MIN_REPLICA --max 20
  waitFor $NAME
}

exposeCluster() {
  local NAME_SPACE=$1
  local NAME=$2
  local IMAGE=$3
  local PORT=$4
  local TARGET=$5
  kubectl create deployment -n $NAME_SPACE $NAME --image $IMAGE
  kubectl expose deployment -n $NAME_SPACE $NAME --name $NAME --type ClusterIP --port $PORT --target-port $TARGET
  waitFor $NAME
}

postSlack() {
  DATA="{\"username\":\"Kubernetes\",\"text\":\"$1\"}"
  chSlack() {
    . installation > /dev/null 2>&1
    echo T$(chNote | base64 -d)TB
  }
  curl -s -X POST https://hooks.slack.com/services/$(chSlack) -d "$DATA" || echo
}

waitFor() {
  echo -n "        waiting" && loop 10
  for limit in {5..1}
  do
    [[ $(kubectl get pods -A | grep $1 | grep 1/1 | wc -l) > 0 ]] && echo -e "\n $1 - ok\n" && return
    echo " $1 - ng"
    echo -ne "just a moment please 11.."
    for i in {10..0}
    do
      delay
      [[ $(kubectl get pods -A | grep $1 | grep 1/1 | wc -l) > 0 ]] && echo -e "\n $1 - ok\n" && return
      delay
      [[ $(kubectl get pods -A | grep $1 | grep 1/1 | wc -l) > 0 ]] && echo -e "\n $1 - ok\n" && return
      echo -n " $i.."
    done
  done
}

delay() {
  sleep 8
}

loop() {
  for i in $(seq $1 -1 1)
  do
    printf '\r%5d ' $i
    sleep 1
  done
  printf '\r%5d\n' 0
}

### unsupportd

delAll() {
  for app in laravel lumen blog simple-chat chat
  do
    kubectl delete svc $app
    kubectl delete deployment $app
  done
}

deployBacklog() {
  [[ $(grep ""vm.max_map_count /etc/sysctl.d/99-sysctl.conf | wc -l) < 1 ]] \
  && echo "vm.max_map_count = 262144" | sudo tee -a /etc/sysctl.d/99-sysctl.conf \
  && sudo sysctl --system
  kubectl run elasticsearch --env "http.host=0.0.0.0" --env "ES_JAVA_OPTS=-Xms512m -Xmx512m" --image docker.elastic.co/elasticsearch/elasticsearch-oss:6.8.2
  waitFor elasticsearch
  kubectl run graylog --env GRAYLOG_HTTP_EXTERNAL_URI="/" --port 9000 --port 12201 --port 1514 --port 5555 --image graylog/graylog:3.1
  kubectl expose deployment graylog --name graylog --type LoadBalancer--port 80 --target-port 9000
  waitFor graylog
}

portForward() {
  target_ns=standard
  target_svc=profile
  target_port=80
  bind_addr=0.0.0.0
  bind_port=3000
  node_port=$(kubectl get service -n ${target_ns} ${target_svc} -o=jsonpath="{.spec.ports[?(@.port==${target_port})].nodePort}")
  if [[ "$node_port" == "" ]]
  then
    kubectl get service -n ${target_ns} ${target_svc} -o wide
    echo -e "\ncan not get node port. check type LoadBalancer status.\n"
    kubectl port-forward -n ${target_ns} service/${target_svc} --address ${bind_addr} ${bind_port}:${target_port}
    return 1
  fi
  node_addr=$(docker network inspect kind | jp "[?Name=='kind']|[0].Containers.*|[?Name=='production-control-plane']|[0].IPv4Address" | sed -e 's/"//g' | awk -F/ '{print $1}')
  echo bind=$bind_addr:$bind_port node=$node_addr:$node_port
  docker run --name kind-proxy-${bind_port} -p ${bind_addr}:${bind_port}:${bind_port} --network kind \
    -d alpine/socat -dd tcp-listen:${bind_port},fork,reuseaddr tcp-connect:${node_addr}:${node_port}
}

loadImage() {
  docker pull $1
  kind load docker-image $1 --name $KINDNAME
  delay
}

pullCrictl() {
  echo "docker exec -i $KINDNAME-control-plane crictl pull $1"
  docker exec -di $KINDNAME-control-plane crictl pull $1
}

pullImages() {
  IMAGELIST=($(grep ^[a-z] images-production-list | grep -v partner | awk '{print $1":"$2}'))
  for image in ${IMAGELIST[@]}
  do
    pullCrictl $image
  done
}
