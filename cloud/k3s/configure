#!/usr/bin/env bash

production() {
  export CLUSTER_NAME=production
  export CLUSTER_CONFIG=k3d/production.yaml

  main
}

main() {
  sysctl

  . k3sVolume

  echo -n "setup '$CLUSTER_NAME' deployment "
  read -p "ok? (y/N): " yn; case "$yn" in [yY]*) echo "continue";; *) echo "abort" && return;; esac

  k3d cluster create --config $CLUSTER_CONFIG

  . initImage
  . metricsServer
  . adminDashboard
  . networkService

  createTlsSecret default
  kubectl -n default apply -f backend/limitrange-limits.yaml

  kubectl create namespace jsxjp
  createTlsSecret jsxjp
  kubectl -n jsxjp apply -f backend/jsxjp/components.yaml 

  kubectl create namespace mqtt
  createTlsSecret mqtt
  kubectl -n mqtt apply -f backend/mqtt/components.yaml 

  . createReverse
  # . createDatabase
  # . createStandard

  createCronJob
  createCodeServer

  echo -n "        ending" && loop 20 --silent

  kubectl get pods -A -o wide
  kubectl top pods -n standard --containers | sort -h -k 4
  echo -e '\n\nk8s creation finished.\n\n'

  createTlsSecret kubernetes-dashboard
  sleep 30
  echo "kubectl -n kubernetes-dashboard apply -f backend/k8s"
  sleep 10
  kubectl -n kubernetes-dashboard apply -f backend/k8s
  sleep 10

  token && post-slack "url: https://k8s.jsx.jp token: $(token)"
  echo Completed.
}

sysctl() {
  [[ 2 -ge $(sudo grep fs.inotify.max_user /etc/sysctl.conf | wc -l) ]] && return 0
  echo 'Setup "/etc/sysctl.conf" fs.inotify.max_user 512M'
  echo '
fs.inotify.max_user_watches=524288
fs.inotify.max_user_instances=8192' | sudo tee -a /etc/sysctl.conf
  sudo sysctl -p
  echo
  sleep 2
}

initNetwork() {
  sudo systemctl disable systemd-resolved --now
  sudo systemctl mask systemd-resolved
  sudo apt purge -y systemd-resolved
}

token() {
  [[ "$(kubectl get namespaces | grep kubernetes-dashboard)" == "" ]] && echo 'no token' && return
  kubectl describe secrets -n kubernetes-dashboard admin-user | grep ^token | awk '{print $2}'
}

partnerContainer() {
  [[ $CLUSTER_NAME == production ]] \
  && backend/partner/create-secret.sh \
  && kubectl apply -f backend/partner && waitFor partner
}

createTlsSecret() {
  rm -fr tls && unzip /home/docker/partner/tls.zip -d tls
  kubectl create secret tls jsxjp-tls \
  --cert=tls/jsx.jp/fullchain.pem \
  --key=tls/jsx.jp/privkey.pem \
  --dry-run=client -o yaml | kubectl -n $1 apply -f -
}

. /etc/os-release
BASIC_SECRET=$VERSION_CODENAME

ingressBasicAuth() {
  BASIC_CREDENTIALS=$(htpasswd -nb bookworm "${BASIC_SECRET}")
  kubectl create secret generic basic-auth \
  --from-literal=users="bookworm:${BASIC_CREDENTIALS}" \
  --dry-run=client -o yaml | kubectl -n $1 apply -f -
}

createCodeServer() {
  kubectl create namespace code-server
  createTlsSecret code-server
  ingressBasicAuth code-server
  kubectl -n code-server apply -f backend/code-server && waitFor code-server
}

makePasswd() {
  head -c 8 /dev/random | mkpasswd -s -5 | sed -e 's/\$//g' | sed -e 's/^1//'
}

genPasswd() {
  GEN_PASSWD="$1"
  [[ "$GEN_PASSWD" == "" ]] && echo -e "failed password.\nusage:\n\n  GEN_PASSWD='$(makePasswd)' genPasswd\n" && return
  kubectl -n wetty exec -i svc/wetty -- bash -c "echo bookworm:$GEN_PASSWD | chpasswd"
}

createCronJob() {
  [[ "$CLUSTER_NAME" != production ]] && return
  kubectl create namespace cron-job
  # kubectl create cronjob -n cron-job value-domain --image ghcr.io/jobscale/value-domain --schedule='6/7 * * * *'

  # kubectl create cronjob -n cron-job health-check --image ghcr.io/jobscale/health-check --schedule='8-55/11 * * * *'
  # kubectl create job -n cron-job health-check-$(date +%s%3N) --from=cronjob.batch/health-check

  kubectl create cronjob -n cron-job remind --image ghcr.io/jobscale/remind --schedule='* * * * *'

  kubectl create cronjob -n cron-job kabuka --image ghcr.io/jobscale/kabuka --schedule='33 0,6 * * 1-5'
  ## Create One time job
  # kubectl create job -n cron-job kabuka-$(date +%s%3N) --from=cronjob.batch/kabuka

  kubectl create cronjob -n cron-job news-top --image ghcr.io/jobscale/news-top --schedule='9-55/11 * * * *'
  ## Create One time job
  # docker exec -it ${ENV:-production}-control-plane crictl pull ghcr.io/jobscale/news-top
  # kubectl create job -n cron-job news-top-$(date +%s%3N) --from=cronjob.batch/news-top

  kubectl create cronjob -n cron-job info-certificate --image ghcr.io/jobscale/info-certificate --schedule='48 23 * * *'
  ## Create One time job
  # docker exec -it ${ENV:-production}-control-plane crictl pull ghcr.io/jobscale/info-certificate
  # kubectl create job -n cron-job info-certificate-$(date +%s%3N) --from=cronjob.batch/info-certificate

  kubectl create cronjob -n cron-job speedtest --image ghcr.io/jobscale/speedtest --schedule '54 0,1,23 * * *'
  ## Create One time job
  # docker exec -it ${ENV:-production}-control-plane crictl pull ghcr.io/jobscale/speedtest
  # kubectl create job -n cron-job speedtest-$(date +%s%3N) --from=cronjob.batch/speedtest
}

waitFor() {
  echo -n "        waiting" && loop 10 --silent
  for limit in {3..1}
  do
    [[ $(kubectl get pods -A | grep $1 | grep 1/1 | wc -l) > 0 ]] && echo -e "\n $1 - ok\n" && return
    echo " $1 - ng"
    echo -ne "just a moment please 6.."
    for i in {5..0}
    do
      delay
      [[ $(kubectl get pods -A | grep $1 | grep 1/1 | wc -l) > 0 ]] && echo -e "\n $1 - ok\n" && return
      delay
      [[ $(kubectl get pods -A | grep $1 | grep 1/1 | wc -l) > 0 ]] && echo -e "\n $1 - ok\n" && return
      echo -n " $i.."
    done
  done
}

loadImage() {
  docker pull $1
  k3d image import $1 -c $CLUSTER_NAME
  delay
}

delay() { sleep 8; }

loop() { loop.js $@; }
