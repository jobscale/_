mkcd() {
  mkdir $1 && cd $_
}

b() {
  sudo cp -pr $1{,.B-$(date +'%Y%m%d%H%M%S')} && echo "backuped --- $1.B-$(date +'%Y%m%d%H%M%S')"
}

docker() {
  if [[ $@ == "ps -a" ]]
  then
    cmd="docker container ls -as --format 'table {{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Size}}\t{{.Status}}'"
    echo "$cmd"
    bash -c "$cmd"
    return
  fi
  if [[ $@ == "ps" ]]
  then
    cmd="docker ps --format 'table {{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Status}}'"
    echo "$cmd"
    bash -c "$cmd"
    return
  fi
  if [[ $@ == "images" ]]
  then
    cmd="docker images '--format={{.CreatedAt}} {{.ID}} {{.Size}} {{.Repository}}:{{.Tag}}' | sort"
    echo "$cmd"
    bash -c "$cmd"
    return
  fi
  command docker "$@"
}

VBoxManage() {
  if [[ $@ == "list vms" ]]
  then
    cmd='VBoxManage list vms --long | grep -e Name: -e State: -e Rule'
    echo "$cmd"
    bash -c "$cmd"
    return
  fi
  if [[ $@ == "controlvm" ]]
  then
    echo VBoxManage controlvm jammy natpf1 "ssh,tcp,0.0.0.0,2022,,22"
    echo VBoxManage controlvm jammy natpf1 delete ssh
    command VBoxManage "$@"
    return
  fi
  command VBoxManage "$@"
}

savestate() {
  VBoxManage controlvm local-stack savestate
  echo "lo-stack saved state"
}

lo-stack() {
  VBoxManage startvm --type headless local-stack
  echo "lo-stack start headless"
}

echo $SHELL | grep zsh || git() {
  if [[ $1 == "clone" && $2 == "--depth" ]]
  then
    shift
    cmd="git clone --depth 1 $4"
    echo "$cmd"
    command $cmd
    return
  fi
  if [[ $1 == "sort" ]]
  then
    cmd="git ls-remote --tags | sort -t '/' -k 3 -V"
    echo "$cmd"
    bash -c "$cmd"
    return
  fi
  if [[ $@ == "branch -a" ]]
  then
    cmd="git fetch --all --prune --tags"
    echo "$cmd"
    command $cmd
    cmd="git branch -a -vv"
    echo "$cmd"
    command $cmd
    return
  fi
  if [[ $@ == "log --all" ]]
  then
    cmd="git --no-pager log --simplify-by-decoration --tags --branches --remotes --date-order --decorate --pretty=\"tformat:%Cblue %h %Creset %<(25)%ci %C(auto)%d%Creset %s\""
    echo "$cmd"
    eval "$cmd"
    return
  fi
  if [[ $@ == "log" ]]
  then
    cmd="git log --date=iso-strict"
    echo "$cmd"
    command $cmd
    return
  fi
  if [[ $1 == "checkout" ]]
  then
    cmd="git $@"
    command $cmd
    [[ ! -s "$2" ]] && {
      cmd="git pull"
      echo "$cmd"
      command $cmd
    }
    return
  fi
  command git "$@"
}

realdir() {
  if [ "-bash" == "$0" ]
  then
    pwd
    return
  fi
  dir=$(dirname "$0")
  if [ -d "$dir" ]
  then
    echo $(cd "$dir" && pwd)
  else
    pwd
  fi
}

skip() {
  for i in $(seq 1 $1)
  do
    echo
  done
}

loop() {
  local duration_ms=$(( $1 * 1000 ))
  local start_time=$(date +%s%3N)
  local end_time=$(( start_time + duration_ms ))
  local step=${3:-1}
  local tick_ms=$(( 1000 / step ))

  while true; do
    local now=$(date +%s%3N)
    local left=$(( end_time - now ))
    if [ $left -le 0 ]; then
      break
    fi

    if [[ $step == 1 ]]; then
      local remaining_sec=$(printf "%d" "$(( left / 1000 + 1 ))")
      printf "\r%5s " "$remaining_sec"
    else
      local remaining_sec=$(printf "%.2f" "$(echo "$left / 1000" | bc -l)")
      printf "\r%8s " "$remaining_sec"
    fi

    # nextTick = ceil((left % 1000) % tick) || tick
    local mod1=$(( left % 1000 ))
    local mod2=$(( mod1 % tick_ms ))
    local next_tick=$(( mod2 > 0 ? mod2 : tick_ms ))
    sleep $(printf "%.3f" "$(echo "$next_tick / 1000" | bc -l)")
  done

  local actual_elapsed=$(printf "%.3f" "$(echo "($(date +%s%3N) - $start_time) / 1000" | bc -l)")
  printf "\r%5s    (%s)\n" "0" "$actual_elapsed"

  if [[ "$2" != "silent" ]] && which ffplay > /dev/null; then
    ffplay -nodisp -autoexit -ss 0 -t 2 "$HOME/_/quest/sand.mp3" > /dev/null 2>&1
  fi
}

gff() {
  while read file
  do
    grep $@ "${file}"
  done < <(ff)
}

tree_html() {
  tree -L 3 -H . $PWD -o tree.html
  open tree.html
}

less_with_unbuffer () {
  unbuffer "$@" 2>&1 | less -SR
}
